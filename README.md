# Í°å‚Äç Pathfinding com labirinto din√¢mico: Aut√¥matos Celulares + √Årvores na pr√°tica! üå≥

No labirinto a seguir, √© trivial sair do canto superior esquerdo e chegar no canto inferior direito:

<p align="center">
  <img src="docs/01_Trivial.gif" style="display: block; margin: 0 auto" />
</p>

Mas como voc√™ faria isso se o labirinto mudasse (deterministicamente) a cada movimento?

<p align="center">
  <img src="docs/02_Dynamic.gif" style="display: block; margin: 0 auto" />
</p>

E em labirintos maiores? T√™m como resolver com a menor quantidade poss√≠vel de movimentos?

<p align="center">
  <img src="docs/03_PacMan.gif" style="display: block; margin: 0 auto" />
</p>

## O que isso tem haver com Aut√¥matos Celulares e √Årvores?

Bem, esse labirinto din√¢mico √© um **Aut√¥mato Celular** e o algoritmo que encontra o caminho at√© a sa√≠da utiliza como base uma **√Årvore** para otimizar a busca da solu√ß√£o!

Se voc√™ reparar bem, todos os labirintos seguem as seguintes regras de mudan√ßa a cada movimento:

- As c√©lulas cinza com 2 ou 3 vizinhos viram az√∫is na pr√≥xima gera√ß√£o.
- As c√©lulas az√∫is com 4 ou 5 ou 6 vizinhos permanecem az√∫is. Do contr√°rio, viram cinza.

Al√©m disso, a pr√≥pria busca pelo caminho √© naturalmente modelada como uma √°rvore, onde cada movimento aumenta uma unidade na profundidade da mesma.

A seguir podemos ver a √°rvore sendo formada. Nela, cada bolinha verde √© um n√≥ folha que representa o final de um poss√≠vel caminho at√© √† sa√≠da do labirinto. N√≥s folha que n√£o conseguem mais se expandir s√£o podados da √°rvore, pois representam caminhos sem sa√≠da. Quando algum n√≥ folha chega na sa√≠da, encontramos um caminho solu√ß√£o do labirinto.

<p align="center">
  <img src="docs/04_Tree.gif" style="display: block; margin: 0 auto" />
</p>

## O projeto conta ainda com 4 modos de jogo:

### Fun

Voc√™ pode jogar manualmente usando o teclado (al√©m de poder ativar/desativar a exibi√ß√£o de quantidade de vizinhos + hints de pr√≥ximo estado):

<p align="center">
  <img src="docs/05_FunMode.gif" style="display: block; margin: 0 auto" />
</p>

### Debug

Voc√™ pode ver o algoritmo rodando passo a passo (controlando a execu√ß√£o via teclado). Bem √∫til para entender como o algoritmo funciona.

### Replay

√â poss√≠vel fazer a bolinha verde seguir uma sequ√™ncia de movimentos informada:

Um caminho pode ser representado como uma sequ√™ncia de movimentos (Up, Right, Down, Left).

Logo, podemos usar um caminho como input e fazer a bolinha seguir ele (funcionando como um replay de uma partida anterior).

Exemplo: DDDDDRRLUUURRRDRLDDRRDR

<p align="center">
  <img src="docs/06_Replay.gif" style="display: block; margin: 0 auto" />
</p>

### Release

Para labirintos gigantes onde queremos apenas a solu√ß√£o final, sem ficar renderizando na tela cada movimento.

Gerei alguns tabuleiros com estado inicial aleat√≥rio (e tamanhos cada vez maiores) pra ver:

- Quantos movimentos s√£o necess√°rios para chegar na sa√≠da
- Quanto tempo leva pro algoritmo encontrar a solu√ß√£o

| Size                  | Moves | Time |
|-----------------------|-------|------|
| 100 x 100             |       |      |
| 1.000 x 1.000         |       |      |
| 10.000 x 10.000       |       |      |
| 100.000 x 100.000     |       |      |
| 1.000.000 x 1.000.000 |       |      |

O projeto conta ainda com mais de 100 casos de teste, pois utilizei o TDD durante grande parte da implementa√ß√£o:

<p align="center">
  <img src="docs/07_Tests.gif" style="display: block; margin: 0 auto" />
</p>

C√≥digo completo no GitHub: https://github.com/ZaqueuCavalcante/mayz

> Encontrei esse problema em um desafio da Stone anos atr√°s, que foi coordenado pelo pessoal da Sigma Geek.
